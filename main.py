import os
import base64
import json
import time
import requests
import fitz  # PyMuPDF
from fastapi import FastAPI, HTTPException, Request, Body
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from dotenv import load_dotenv
import tempfile
import logging

# ==== LOGGING CONFIGURATION ====
logging.basicConfig(
    level=logging.INFO,  # Change to DEBUG if needed
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

load_dotenv()

# ==== CONFIG ====
API_KEY = os.getenv("GEMINI_API_KEY")
API_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={API_KEY}"

# ==== FASTAPI APP ====
app = FastAPI(title="PDF Summarization Microservice ðŸš€")

# ==== Middleware for Logging ====
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    logger.info(f"Incoming request: {request.method} {request.url}")

    try:
        response = await call_next(request)
    except Exception as e:
        logger.exception(f"Unhandled error during request: {e}")
        raise

    duration = time.time() - start_time
    logger.info(
        f"Completed request: {request.method} {request.url} "
        f"Status: {response.status_code} Duration: {duration:.2f}s"
    )
    return response

# ==== Helper Functions ====
def get_backoff_delay(attempt: int) -> int:
    return min(1000 * (2 ** attempt), 60000)

def call_gemini_api_with_retry(payload: dict, max_retries: int = 3) -> str:
    headers = {"Content-Type": "application/json"}
    last_exception = None
    response = None

    for attempt in range(max_retries + 1):
        try:
            logger.info(f"Attempt {attempt+1} to call Gemini API...")
            response = requests.post(API_URL, headers=headers, data=json.dumps(payload))
            response.raise_for_status()

            result = response.json()
            candidates = result.get("candidates")
            if candidates and candidates[0].get("content"):
                parts = candidates[0]["content"].get("parts")
                if parts and "text" in parts[0]:
                    return parts[0]["text"]

            return "No summary was generated by Gemini API."

        except requests.exceptions.RequestException as e:
            last_exception = e
            if response is not None and response.status_code == 429 and attempt < max_retries:
                delay = get_backoff_delay(attempt) / 1000
                logger.warning(f"Rate limit hit. Retrying in {delay}s...")
                time.sleep(delay)
            else:
                logger.error(f"Gemini API request failed: {str(e)}")
                break

    return f"Error: Failed to get summary. Details: {str(last_exception)}"

def extract_text_from_pdf(file_path: str) -> str:
    try:
        doc = fitz.open(file_path)
        full_text = "".join(page.get_text() for page in doc)
        doc.close()
        return full_text
    except Exception as e:
        logger.error(f"Error extracting text from PDF: {e}")
        return f"Error extracting text: {e}"

def extract_images_and_summarize(file_path: str, word_count: int) -> str:
    try:
        doc = fitz.open(file_path)
        payload_parts = [
            {"text": f"Please summarize the following document."}
        ]

        for page_num, page in enumerate(doc, start=1):
            pix = page.get_pixmap(dpi=300)
            img_bytes = pix.tobytes("png")
            base64_img = base64.b64encode(img_bytes).decode("utf-8")
            payload_parts.append(
                {"inlineData": {"mimeType": "image/png", "data": base64_img}}
            )
            logger.info(f"Page {page_num} converted to base64 image.")

        doc.close()
        payload = {"contents": [{"parts": payload_parts}]}
        logger.info("Sending image payload to Gemini API.")
        return call_gemini_api_with_retry(payload)

    except Exception as e:
        logger.error(f"Error during image summarization: {e}")
        return f"Error during image summarization: {e}"

# ==== Routes ====
@app.get("/")
def health_check():
    return {"message": "PDF Summarization Microservice running ðŸš€"}

class SummarizeRequest(BaseModel):
    fileUrl: str = Field(..., alias="fileUrl")
    word_count: int = Field(200, alias="wordCount")

    class Config:
        allow_population_by_field_name = True

@app.post("/document/summarize")
async def summarize_pdf(request: SummarizeRequest = Body(...)):
    logger.info(f"Summarize endpoint hit with payload: {request.dict()}")
    temp_path = None

    try:
        response = requests.get(request.fileUrl, stream=True)
        if response.status_code != 200:
            logger.error(f"Failed to download PDF. Status: {response.status_code}, URL: {request.fileUrl}")
            raise HTTPException(status_code=400, detail="Failed to download PDF from URL")

        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_file:
            tmp_file.write(response.content)
            temp_path = tmp_file.name

        logger.info(f"PDF downloaded and saved at {temp_path}")

        extracted_text = extract_text_from_pdf(temp_path)
        logger.info(f"Extracted text length: {len(extracted_text)} characters")

        if extracted_text.strip() and not extracted_text.startswith("Error"):
            prompt = (
                f"Please summarize the following document.\n\n"
                f"Document:\n{extracted_text}"
            )
            payload = {"contents": [{"parts": [{"text": prompt}]}]}
            logger.info("Sending text payload to Gemini API.")
            summary = call_gemini_api_with_retry(payload)
        else:
            logger.warning("No text found, falling back to image summarization.")
            summary = extract_images_and_summarize(temp_path, request.word_count)
        print(summary)
        return JSONResponse(content={"summary": summary})

    except Exception as e:
        logger.exception(f"Unexpected error in summarize_pdf: {e}")
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        if temp_path and os.path.exists(temp_path):
            os.remove(temp_path)
            logger.info("Temporary file deleted.")
