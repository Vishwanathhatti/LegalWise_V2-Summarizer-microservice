import os
import base64
import json
import time
import requests
import fitz  # PyMuPDF
from fastapi import FastAPI, HTTPException, Request, Body
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from dotenv import load_dotenv
import tempfile
import logging
import google.generativeai as genai

# ==== LOGGING CONFIGURATION ====
logging.basicConfig(
    level=logging.INFO,  # Change to DEBUG if needed
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

load_dotenv()

# ==== CONFIG ====
API_KEY = os.getenv("GEMINI_API_KEY")
genai.configure(api_key=API_KEY)


# ==== FASTAPI APP ====
app = FastAPI(title="PDF Summarization Microservice ðŸš€")

# ==== Middleware for Logging ====
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    logger.info(f"Incoming request: {request.method} {request.url}")

    try:
        response = await call_next(request)
    except Exception as e:
        logger.exception(f"Unhandled error during request: {e}")
        raise

    duration = time.time() - start_time
    logger.info(
        f"Completed request: {request.method} {request.url} "
        f"Status: {response.status_code} Duration: {duration:.2f}s"
    )
    return response

# ==== Helper Functions ====
def call_gemini_api_with_retry(prompt: str, max_retries: int = 3) -> str:
    """Call Gemini API with retry logic using official SDK"""
    last_exception = None

    for attempt in range(max_retries + 1):
        try:
            logger.info(f"Attempt {attempt+1} to call Gemini API...")
            
            # Use the official SDK with gemini-2.5-flash (better free tier support)
            model = genai.GenerativeModel('gemini-2.5-flash')
            response = model.generate_content(prompt)
            
            if response.text:
                return response.text
            
            return "No summary was generated by Gemini API."

        except Exception as e:
            last_exception = e
            if attempt < max_retries:
                delay = min(2 ** attempt, 10)  # Exponential backoff, max 10 seconds
                logger.warning(f"API call failed. Retrying in {delay}s... Error: {str(e)}")
                time.sleep(delay)
            else:
                logger.error(f"Gemini API request failed after {max_retries + 1} attempts: {str(e)}")
                break

    return f"Error: Failed to get summary. Details: {str(last_exception)}"


def extract_text_from_pdf(file_path: str) -> str:
    try:
        doc = fitz.open(file_path)
        full_text = "".join(page.get_text() for page in doc)
        doc.close()
        return full_text
    except Exception as e:
        logger.error(f"Error extracting text from PDF: {e}")
        return f"Error extracting text: {e}"

def extract_images_and_summarize(file_path: str, word_count: int) -> str:
    try:
        doc = fitz.open(file_path)
        
        # For image-based summarization, we'll use the SDK's multimodal capabilities
        logger.info("Processing document with images for summarization...")
        
        model = genai.GenerativeModel('gemini-2.5-flash')
        parts = ["Please summarize the following document."]
        
        for page_num, page in enumerate(doc, start=1):
            pix = page.get_pixmap(dpi=300)
            img_bytes = pix.tobytes("png")
            
            # Create PIL Image for SDK
            from PIL import Image
            import io
            img = Image.open(io.BytesIO(img_bytes))
            parts.append(img)
            logger.info(f"Page {page_num} added to summarization request.")

        doc.close()
        logger.info("Sending image payload to Gemini API using SDK.")
        response = model.generate_content(parts)
        
        if response.text:
            return response.text
        return "No summary was generated by Gemini API."

    except Exception as e:
        logger.error(f"Error during image summarization: {e}")
        return f"Error during image summarization: {e}"


# ==== Routes ====
@app.get("/")
def health_check():
    return {"message": "PDF Summarization Microservice running ðŸš€"}

class SummarizeRequest(BaseModel):
    fileUrl: str = Field(..., alias="fileUrl")
    word_count: int = Field(200, alias="wordCount")

    class Config:
        allow_population_by_field_name = True

@app.post("/document/summarize")
async def summarize_pdf(request: SummarizeRequest = Body(...)):
    logger.info(f"Summarize endpoint hit with payload: {request.dict()}")
    temp_path = None

    try:
        response = requests.get(request.fileUrl, stream=True)
        if response.status_code != 200:
            logger.error(f"Failed to download PDF. Status: {response.status_code}, URL: {request.fileUrl}")
            raise HTTPException(status_code=400, detail="Failed to download PDF from URL")

        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_file:
            tmp_file.write(response.content)
            temp_path = tmp_file.name

        logger.info(f"PDF downloaded and saved at {temp_path}")

        extracted_text = extract_text_from_pdf(temp_path)
        logger.info(f"Extracted text length: {len(extracted_text)} characters")

        if extracted_text.strip() and not extracted_text.startswith("Error"):
            prompt = (
                f"Please summarize the following document.\n\n"
                f"Document:\n{extracted_text}"
            )
            logger.info("Sending text payload to Gemini API.")
            summary = call_gemini_api_with_retry(prompt)
        else:
            logger.warning("No text found, falling back to image summarization.")
            summary = extract_images_and_summarize(temp_path, request.word_count)
        
        print(summary)
        return JSONResponse(content={"summary": summary})

    except Exception as e:
        logger.exception(f"Unexpected error in summarize_pdf: {e}")
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        if temp_path and os.path.exists(temp_path):
            os.remove(temp_path)
            logger.info("Temporary file deleted.")
